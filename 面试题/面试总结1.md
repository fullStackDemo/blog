最近一直在面试，却很少总结，反思了一下，这是不应该的。所以打算认真写一下。

**先说下笔试题**

#### Q1:

关于基本类型和==typeof==, 问的还是挺偏的

```javascript
// number
typeof NaN
// number
typeof 12
// string
typeof "12"
// object
typeof null
// undefined
typeof undefined
// object
typeof Date
// object
typeof {a:1}
// object
typeof [1]
// function
typeof function(){}
// true
null == undefined
// false
NaN == NaN
```

类型判断这块的东西，比较基础，却容易混乱，接下来让我们深层次了解下这个东西。

![img](./assets/1.jpeg)

既然是数据类型判断，无可避免需要先说一下，==基本类型==有哪几种：

* String 
* Number
* null
* undefined
* Boolean
* Symbol(Es6)

这六个属于基本数据类型，当然除此之外还有 ==Object== 这个属于引用类型。对象类型是有名字和键值的一个组合。

看到这里我们不禁会问，==arrays==、==functions==、==regular expressions==、==Date==、==Error==等等又算什么。它们只是特殊的Object.

**Example**

```javascript
console.log(typeof ""); // "string"
console.log(typeof "hello"); // "string"
console.log(typeof String("hello")); // "string"
console.log(typeof new String("hello")); // "object"

console.log(typeof 0); // "number"
console.log(typeof -0); // "number"
console.log(typeof 0xff); // "number"
console.log(typeof -3.142); // "number"
console.log(typeof Infinity); // "number"
console.log(typeof -Infinity); // "number"
console.log(typeof NaN); // "number"
console.log(typeof Number(53)); // "number"
console.log(typeof new Number(53)); // "object"

console.log(typeof true); // "boolean"
console.log(typeof false); // "boolean"
console.log(typeof new Boolean(true)); // "object"

console.log(typeof undefined); // "undefined"

console.log(typeof null); // "object"

console.log(typeof Symbol()); // "symbol"

console.log(typeof []); // "object"
console.log(typeof Array(5)); // "object"

console.log(typeof function () {}); // "function"
console.log(typeof new Function); // "function"

console.log(typeof new Date); // "object"

console.log(typeof /^(.+)$/); // "object"
console.log(typeof new RegExp("^(.+)$")); // "object"

console.log(typeof {}); // "object"
console.log(typeof new Object); // "object"
```

| value                | typeof                        |
| -------------------- | ----------------------------- |
| `undefined`          | `"undefined"`                 |
| `null`               | `"object"`                    |
| `true` or `false`    | `"boolean"`                   |
| all numbers or `NaN` | `"number"`                    |
| all strings          | `"string"`                    |
| all symbols          | `"symbol"`                    |
| all functions        | `"function"`                  |
| all arrays           | `"object"`                    |
| native objects       | `"object"`                    |
| host objects         | *dependent on implementation* |
| other objects        | `"object"`                    |

你或许经常碰到这句话；

![1557903486895](assets/1557903486895.png)

这句话其实是在某些点上是错的。

很多人也许会问，那为什么有些不是对象但是我们依然可以如下调用对象的方法呢？

```javascript
// getting length property of the string
(“Hello World!”).length
//   getting the character of the string at index 8
(“Another String”)[8]
//  calling Number.prototype.toFixed() method on the number
(53.12345).toFixed(2) 
```

真实的原因是javascript引擎创造了一个wrapped object 和这个原始语句相对应。

```javascript
// wrapper object: new String("Hello World!")
(new String("Hello World!")).toLowerCase();

// wrapper object: new String("Another String")
(new String("Another String"))[8];

// wrapper object: new Number(53.12345)
(new Number(53.12345)).toFixed(2);
```

再次说下类型比较，==null== 和 ==[]==通过==typeof== 判断都返回 ==object==， 此时我们怎么样才能进行深层次的区分呢？

##### 比较精确的类型比较，大概要通过下面几种方法

* instanceof operator

* checking the constructor property of the object

* 使用 toString() 方法检查类型.
  

  #### Checking for null

  ```javascript
  function isNull(val){
  	return val === null
  }
  
  console.log(undefined == null); // true
  console.log(undefined === null); // false
  ```

  #### Checking for NaN

  NaN是一个计算导致的结果，一般没有实质意思。前面说过 typeof NaN = number 如果想进一步区分，可以通过 isNaN 或者 es6的 Number.isNaN()

  ```javascript
  typeof NaN //number
  
  console.log(isNaN(NaN)); // true
  console.log(isNaN(null)); // false
  console.log(isNaN(undefined)); // true
  console.log(isNaN(Infinity)); // false
  
  console.log(Number.isNaN(NaN)); // true
  console.log(Number.isNaN(null)); // false
  console.log(Number.isNaN(undefined)); // false
  console.log(Number.isNaN(Infinity)); // false
  ```

  

  最终用法,兼容es6：

```javascript
Number.isNaN = Number.isNaN || (function(value) {
  return value !== value;
})
```

#### 	Checking for arrays

```javascript

// METHOD 1: constructor property
// Not reliable
function isArray(value) {
  return typeof value == 'object' && value.constructor === Array;
}

// METHOD 2: instanceof
// Not reliable since an object's prototype can be changed
// Unexpected results within frames
function isArray(value) {
  return value instanceof Array;
}

// METHOD 3: Object.prototype.toString()
// Better option and very similar to ES6 Array.isArray()
function isArray(value) {
  return Object.prototype.toString.call(value) === '[object Array]';
}

// METHOD 4: ES6 Array.isArray()
function isArray(value) {
  return Array.isArray(value);
}
```

其实最常用的 Object.prototype.toString.call(data) 是很有用的（apply也可以）。不过我们可以封装一下：

```javascript
function type(value){
	const regex = /^\[object (\S+?)\]$/;
	const matches = Object.prototype.toString.call(value).match(regex) || [];
	return (matches[1] || "undefined").toLowerCase();
}
```

**Example**

```javascript
console.log(type('')); // "string"
console.log(type('hello')); // "string"
console.log(type(String('hello'))); // "string"
console.log(type(new String('hello'))); // "string"

console.log(type(0)); // "number"
console.log(type(-0)); // "number"
console.log(type(0xff)); // "number"
console.log(type(-3.142)); // "number"
console.log(type(Infinity)); // "number"
console.log(type(-Infinity)); // "number"
console.log(type(NaN)); // "number"
console.log(type(Number(53))); // "number"
console.log(type(new Number(53))); // "number"

console.log(type(true)); // "boolean"
console.log(type(false)); // "boolean"
console.log(type(new Boolean(true))); // "boolean"

console.log(type(undefined)); // "undefined"

console.log(type(null)); // "null"

console.log(type(Symbol())); // "symbol"
console.log(type(Symbol.species)); // "symbol"

console.log(type([])); // "array"
console.log(type(Array(5))); // "array"

console.log((function() { return type(arguments) })()); // "arguments"

console.log(type(function() {})); // "function"
console.log(type(new Function)); // "function"

console.log(type(class {})); // "function"

console.log(type({})); // "object"
console.log(type(new Object)); // "object"

console.log(type(/^(.+)$/)); // "regexp"
console.log(type(new RegExp("^(.+)$"))); // "regexp"

console.log(type(new Date)); // "date"
console.log(type(new Set)); // "set"
console.log(type(new Map)); // "map"
console.log(type(new WeakSet)); // "weakset"
console.log(type(new WeakMap)); // "weakmap"
```

