##双向数据绑定

Vue里面的数据绑定是通过==数据劫持==的方式来实现的，

其中最核心的便是==Object.defineProperty()==。

双向数据绑定，简单点来说分为三个部分：

* 1、`Observer`。这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的watcher。

* 2、`Watcher`。观察者，当监听的数据值修改时，执行响应的回调函数（`Vue`里面的更新模板内容）。

* 3、`Dep`。连接`Observer`和`Watcher`的桥梁，每一个`Observer`对应一个`Dep`，它内部维护一个数组，保存与该`Observer`相关的`Watcher`。

## `example`
这里不做数组的监听，只做一个对象的demo


~~~js
<div id="test1"></div>
<div id="test2"></div>

<script>

/**
* Observer
* 监听者
* 遍历Object的每一个属性，添加 getter 和 setter
* 如果在调用 obj.a 时候 会触发 getter 这时候把 watcher 添加到 dep 中，
* 重新赋值 obj.a 时候，会触发 setter, 这时候调用 watcher.update 回调函数
*/
function Observer(obj, key, value){
  const dep = new Dep();
  if(Object.prototype.toString.call(value) == '[object Object]'){
    Object.keys(value).forEach(key=>{
      new Observer(value, key, value[key])
    });
  }
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get: function(){
      // target 就是 watcher
      if(Dep.target){
          dep.addSub(Dep.target);
      }
      return value;
    },
    set: function (newVal) {
      value = newVal;
      dep.notify();
    }
  })
}

/**
* watcher
* 观察者
* fn是数据变化后要执行的回调函数，一般是获取数据渲染模板
* 默认执行一遍update方法是为了在渲染模板过程中，调用数据对象的getter时建立两者之间的关系
* 因为同一时刻只有一个watcher处于激活状态，把当前watcher绑定在Dep.target（方便在Observer内获取）
* 回调结束后，销毁 Dep.target
*/
function Watcher(fn) {
  this.update = function(){
    Dep.target = this;
    fn();
    Dep.target = null;
  }
  this.update();
}

/**
* Dep
* 中间桥梁
* 内部一个存放watcher的数组subs
* addSub用于向数组中添加watcher(getter时)
* notify用于触发watcher的更新(setter时)
*/
function Dep() {
  this.subs=[];
  this.addSub = function(watcher){
    this.subs.push(watcher)
  }
  this.notify = function(){
    this.subs.forEach(watcher=>{
      watcher.update();
    })
  }
}


//执行

var obj = {
  a: 88,
  b: {
    name: 'wz'
  }
}
Object.keys(obj).forEach(key=>{
  new Observer(obj, key, obj[key])
});

new Watcher(function(){
  document.querySelector('#test1').innerHTML = obj.a;
  document.querySelector('#test2').innerHTML = obj.b.name;
});

/**
* obj的每一个属性都有自己的 getter 和 setter, 
* 在新建 watcher 时候，自执行的 this.update, 导致执行 watcher 的 回调函数，
* 使得 #test1 的内容显示是 88，#test2 内容显示是 wz
* 此时打开控制台，改变obj.a or obj.b.name, 你会发现显示内容也会同步改变
*/


</script>

